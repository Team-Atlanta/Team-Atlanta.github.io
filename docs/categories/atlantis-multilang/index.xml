<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Atlantis-Multilang on Team Atlanta</title><link>https://team-atlanta.github.io/categories/atlantis-multilang/</link><description>Recent content in Atlantis-Multilang on Team Atlanta</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 20 Aug 2025 05:00:00 +0000</lastBuildDate><atom:link href="https://team-atlanta.github.io/categories/atlantis-multilang/index.xml" rel="self" type="application/rss+xml"/><item><title>Atlantis-Multilang (UniAFL): LLM-powered &amp; Lauguage-agonistic Automatic Bug Finding</title><link>https://team-atlanta.github.io/blog/post-crs-multilang/</link><pubDate>Wed, 20 Aug 2025 05:00:00 +0000</pubDate><guid>https://team-atlanta.github.io/blog/post-crs-multilang/</guid><description>&lt;h2 id="atlantis-multilang--uniafl">Atlantis-Multilang == UniAFL&lt;/h2>
&lt;p>Atlantis-Multilang is a fuzzing framework called UniAFL, designed to LLMs for fuzzing across multiple programming languages.
Unlike Atlantis-C and Atlantis-Java, it avoids language-specific instrumentation and is intentionally built to be as language-agnostic as possible — both in design and execution.
&lt;span style="background-color:lightgray;color:green">Despite this broad and general approach, UniAFL proved to be highly effective in the AIxCC finals, contributing to 69.2% of all POV (Proof-of-Vulnerability) submissions.&lt;/span>
This result highlights not only the flexibility of its design but also its strong performance in practice.
In this post, we’ll walk you through how we pulled it off, why we made these design choices, and what made UniAFL so effective in practice.&lt;/p></description></item></channel></rss>