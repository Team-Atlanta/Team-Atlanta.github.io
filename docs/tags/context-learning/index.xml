<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Context-Learning on Team Atlanta</title><link>https://team-atlanta.github.io/tags/context-learning/</link><description>Recent content in Context-Learning on Team Atlanta</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 02 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://team-atlanta.github.io/tags/context-learning/index.xml" rel="self" type="application/rss+xml"/><item><title>Teaching LLMs to Retrieve: Custom Models for Security Patch Generation</title><link>https://team-atlanta.github.io/blog/post-custom-model/</link><pubDate>Sun, 02 Nov 2025 00:00:00 +0000</pubDate><guid>https://team-atlanta.github.io/blog/post-custom-model/</guid><description>&lt;h2 id="the-typedef-that-changed-everything">The Typedef That Changed Everything&lt;/h2>
&lt;p>Picture this: you&amp;rsquo;re asking an LLM to patch a security vulnerability in Nginx, a codebase with millions of lines. The bug is clear, the fix location is obvious, but your patch won&amp;rsquo;t compile. Why? Because buried somewhere in the headers are two critical &lt;code>typedef&lt;/code> definitions that the LLM never saw.&lt;/p>
&lt;p>We discovered this the hard way during the AIxCC Semifinals. Challenge &lt;code>challenge-004-nginx-cp/cpv15&lt;/code> became our wake-up call. When we ran our baseline patching agent Aider 20 times without the typedef definitions, only 5 patches compiled successfully. But when we included those typedefs? 18 out of 20 compiled successfully. &lt;strong>That 5/20 â†’ 18/20 leap wasn&amp;rsquo;t about smarter LLMs or better prompts. It was about giving the right context.&lt;/strong>&lt;/p></description></item></channel></rss>