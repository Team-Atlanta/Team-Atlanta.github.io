<!doctype html><html itemscope lang=en-us itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=5"><meta name=theme-name content="hugoplate"><link rel="shortcut icon" href=/images/team-icon_huf9440efed39ba7d24ba35d33aee39304_52547_96x0_resize_lanczos.png type=image/x-icon><link rel=icon href=/images/team-icon_huf9440efed39ba7d24ba35d33aee39304_52547_96x0_resize_lanczos.png type=image/x-icon><link rel=icon type=image/png sizes=48x48 href=/images/team-icon_huf9440efed39ba7d24ba35d33aee39304_52547_48x0_resize_lanczos.png><link rel=icon type=image/png sizes=96x96 href=/images/team-icon_huf9440efed39ba7d24ba35d33aee39304_52547_96x0_resize_lanczos.png><link rel=apple-touch-icon sizes=144x144 href=/images/team-icon_huf9440efed39ba7d24ba35d33aee39304_52547_144x0_resize_lanczos.png><link rel=manifest href=/manifest.webmanifest><meta name=msapplication-TileColor content="#ddd"><meta name=theme-color content="#ffffff"><base href=https://team-atlanta.github.io/blog/post-atl/><title>Announcing Team Atlanta!</title>
<meta name=keywords content="DARPA AIxCC,cybersecurity,fuzzing,LLM,AIxCC"><meta name=description content="Beginning"><meta property="og:image" content="https://team-atlanta.github.io/images/blog/atl/team.png"><meta name=twitter:image content="https://team-atlanta.github.io/images/blog/atl/team.png"><meta name=twitter:card content="summary
            _large_image
          "><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1366"><meta property="og:image:type" content="image/
        .png
      "><meta property="og:title" content="Announcing Team Atlanta!"><meta property="og:description" content="Beginning"><meta property="og:type" content="website"><meta property="og:url" content="https://team-atlanta.github.io/blog/post-atl/"><meta name=twitter:title content="Announcing Team Atlanta!"><meta name=twitter:description content="Beginning"><script>let indexURL="https://team-atlanta.github.io/searchindex.json",includeSectionsInSearch=["blog"],no_results_for="No results for",empty_search_results_placeholder="Type something to search.."</script><meta http-equiv=x-dns-prefetch-control content="on"><link rel=preconnect href=https://use.fontawesome.com crossorigin><link rel=preconnect href=//cdnjs.cloudflare.com><link rel=preconnect href=//www.googletagmanager.com><link rel=preconnect href=//www.google-analytics.com><link rel=dns-prefetch href=https://use.fontawesome.com><link rel=dns-prefetch href=//ajax.googleapis.com><link rel=dns-prefetch href=//cdnjs.cloudflare.com><link rel=dns-prefetch href=//www.googletagmanager.com><link rel=dns-prefetch href=//www.google-analytics.com><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//connect.facebook.net><link rel=dns-prefetch href=//platform.linkedin.com><link rel=dns-prefetch href=//platform.twitter.com><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;600&family=Signika:wght@500;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><link href="/css/style.min.a392e71955dab534d5a3ecad916ee94fa4b2cb9afdbfc14ca644be0f2eacb798.css" integrity="sha256-o5LnGVXatTTVo+ytkW7pT6Syy5r9v8FMpkS+Dy6st5g=" rel=stylesheet><link defer async rel=stylesheet href="/css/style-lazy.min.1a9d1009e7f8ece0fee6bf42b15ba299b3f17268c302b871323434f820c6b503.css" integrity="sha256-Gp0QCef47OD+5r9CsVuimbPxcmjDArhxMjQ0+CDGtQM=" media=print onload='this.media="all",this.onload=null'></head><body><header class="header sticky top-0 z-30"><nav class="navbar container"><div class=order-0><a class="navbar-brand block" href=/>Team Atlanta</a></div><input id=nav-toggle type=checkbox class=hidden>
<label for=nav-toggle class="order-3 cursor-pointer flex items-center lg:hidden text-dark dark:text-white lg:order-1"><svg id="show-button" class="h-6 fill-current block" viewBox="0 0 20 20"><title>Menu Open</title><path d="M0 3h20v2H0V3zm0 6h20v2H0V9zm0 6h20v2H0V0z"/></svg><svg id="hide-button" class="h-6 fill-current hidden" viewBox="0 0 20 20"><title>Menu Close</title><polygon points="11 9 22 9 22 11 11 11 11 22 9 22 9 11 -2 11 -2 9 9 9 9 -2 11 -2" transform="rotate(45 10 10)"/></svg></label><ul id=nav-menu class="navbar-nav order-3 hidden lg:flex w-full pb-6 lg:order-1 lg:w-auto lg:space-x-2 lg:pb-0 xl:space-x-8"><li class=nav-item><a class=nav-link href=/>Home</a></li><li class=nav-item><a class=nav-link href=/authors/>AIxCC Team</a></li><li class=nav-item><a class=nav-link href=/about/>About</a></li><li class=nav-item><a class=nav-link href=/blog/>Blog</a></li></ul><div class="order-1 ml-auto flex items-center md:order-2 lg:ml-0"><button aria-label=search class="border-border text-dark hover:text-primary dark:border-darkmode-border mr-5 inline-block border-r pr-5 text-xl dark:text-white dark:hover:text-darkmode-primary" data-target=search-modal>
<i class="fa-solid fa-search"></i></button><div class="theme-switcher mr-5"><input id=theme-switcher data-theme-switcher type=checkbox>
<label for=theme-switcher><span class=sr-only>theme switcher</span>
<span><svg class="absolute left-[4px] top-[4px] z-10 opacity-100 dark:opacity-0" viewBox="0 0 56 56" fill="#fff" height="16" width="16"><path d="M30 4.6c0-1-.9-2-2-2a2 2 0 00-2 2v5c0 1 .9 2 2 2s2-1 2-2zm9.6 9a2 2 0 000 2.8c.8.8 2 .8 2.9.0L46 13a2 2 0 000-2.9 2 2 0 00-3 0zm-26 2.8c.7.8 2 .8 2.8.0.8-.7.8-2 0-2.9L13 10c-.7-.7-2-.8-2.9.0-.7.8-.7 2.1.0 3zM28 16A12 12 0 0016 28a12 12 0 0012 12 12 12 0 0012-12A12 12 0 0028 16zm23.3 14c1.1.0 2-.9 2-2s-.9-2-2-2h-4.9a2 2 0 00-2 2c0 1.1 1 2 2 2zM4.7 26a2 2 0 00-2 2c0 1.1.9 2 2 2h4.9c1 0 2-.9 2-2s-1-2-2-2zm37.8 13.6a2 2 0 00-3 0 2 2 0 000 2.9l3.6 3.5a2 2 0 002.9.0c.8-.8.8-2.1.0-3zM10 43.1a2 2 0 000 2.9c.8.7 2.1.8 3 0l3.4-3.5c.8-.8.8-2.1.0-2.9s-2-.8-2.9.0zm20 3.4c0-1.1-.9-2-2-2a2 2 0 00-2 2v4.9c0 1 .9 2 2 2s2-1 2-2z"/></svg><svg class="absolute left-[4px] top-[4px] z-10 opacity-0 dark:opacity-100" viewBox="0 0 24 24" fill="none" height="16" width="16"><path fill="#000" fill-rule="evenodd" clip-rule="evenodd" d="M8.2 2.2c1-.4 2 .6 1.6 1.5-1 3-.4 6.4 1.8 8.7a8.4 8.4.0 008.7 1.8c1-.3 2 .5 1.5 1.5v.1A10.3 10.3.0 0112.4 22 10.3 10.3.0 013.2 6.7c1-2 2.9-3.5 4.9-4.4z"/></svg></span></label></div><script>var darkMode=!1,themeSwitch;window.matchMedia("(prefers-color-scheme: dark)").matches&&(darkMode=!0),localStorage.getItem("theme")==="dark"?darkMode=!0:localStorage.getItem("theme")==="light"&&(darkMode=!1),darkMode&&document.documentElement.classList.toggle("dark"),themeSwitch=document.querySelectorAll("[data-theme-switcher]"),document.addEventListener("DOMContentLoaded",()=>{[].forEach.call(themeSwitch,function(e){e.checked=!!darkMode,e.addEventListener("click",()=>{document.documentElement.classList.toggle("dark"),localStorage.setItem("theme",document.documentElement.classList.contains("dark")?"dark":"light")})})})</script></div></nav></header><div class=search-modal aria-hidden=true style=--color-primary:#121212><div data-target=close-search-modal class=search-modal-overlay></div><div class=search-wrapper data-image=true data-description=true data-tags=true data-categories=true><div class=search-wrapper-header><label for=search-modal-input style=margin-top:-1px><span class=sr-only>search icon</span>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-icon" data-type="search"><path fill="currentcolor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-reset" data-type="reset"><path fill="currentcolor" d="M256 512A256 256 0 10256 0a256 256 0 100 512zM175 175c9.4-9.4 24.6-9.4 33.9.0l47 47 47-47c9.4-9.4 24.6-9.4 33.9.0s9.4 24.6.0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6.0 33.9s-24.6 9.4-33.9.0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9.0s-9.4-24.6.0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6.0-33.9z"/></svg></label><input id=search-modal-input type=text data-search-input autocomplete=off aria-label=Search placeholder="Search Post ..."></div><div class=search-wrapper-body><div class=search-result data-search-result></div><span class=search-result-empty>Type something to search..</span></div><div class=search-wrapper-footer><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16"><path d="M3.204 11h9.592L8 5.519 3.204 11zm-.753-.659 4.796-5.48a1 1 0 011.506.0l4.796 5.48c.566.647.106 1.659-.753 1.659H3.204a1 1 0 01-.753-1.659z"/></svg></kbd><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" style="margin-top:1px" viewBox="0 0 16 16"><path d="M3.204 5h9.592L8 10.481 3.204 5zm-.753.659 4.796 5.48a1 1 0 001.506.0l4.796-5.48c.566-.647.106-1.659-.753-1.659H3.204a1 1 0 00-.753 1.659z"/></svg></kbd>to navigate
</span><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentcolor" style="display:inline-block" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.5 1.5a.5.5.0 01.5.5v4.8a2.5 2.5.0 01-2.5 2.5H2.707l3.347 3.346a.5.5.0 01-.708.708l-4.2-4.2a.5.5.0 010-.708l4-4a.5.5.0 11.708.708L2.707 8.3H12.5A1.5 1.5.0 0014 6.8V2a.5.5.0 01.5-.5z"/></svg></kbd>to select
</span><span class=search-result-info></span>
<span data-target=close-search-modal><kbd>ESC</kbd> to close</span></div></div></div><main><section class="section pt-7"><div class=container><div class="row justify-center"><article class=lg:col-10><div class=mb-10><picture><source srcset=/images/blog/atl/team_huc3e56ef5e288df5354ff0980117ccdf0_352571_545x0_resize_q90_h2_lanczos_3.webp media="(max-width: 575px)"><source srcset=/images/blog/atl/team_huc3e56ef5e288df5354ff0980117ccdf0_352571_600x0_resize_q90_h2_lanczos_3.webp media="(max-width: 767px)"><source srcset=/images/blog/atl/team_huc3e56ef5e288df5354ff0980117ccdf0_352571_700x0_resize_q90_h2_lanczos_3.webp media="(max-width: 991px)"><source srcset=/images/blog/atl/team_huc3e56ef5e288df5354ff0980117ccdf0_352571_1110x0_resize_q90_h2_lanczos_3.webp><img loading=lazy decoding=async src=/images/blog/atl/team_huc3e56ef5e288df5354ff0980117ccdf0_352571_1110x0_resize_lanczos_3.png class="w-full rounded img" alt="Announcing Team Atlanta!" width=2048 height=1366></picture></div><h1 class="h2 mb-4">Announcing Team Atlanta!</h1><ul class=mb-4><li class="mr-4 inline-block"><a href=/authors/taesoo-kim/><i class="fa-regular fa-circle-user mr-2"></i>Taesoo Kim</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-folder mr-2"></i>
<a href=/categories/announcement/ class=ms-1>Announcement</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-clock mr-2"></i>
August 13, 2024</li></ul><div class="content mb-10"><p>Hello, world! We are <em>Team Atlanta</em>, the minds behind Atlantis, our innovative
AI-driven cybersecurity solution competing in the prestigious
<a href=https://aicyberchallenge.com/ target=_blank>DARPA AIxCC</a>
.</p><p><a href=/authors/>Our team</a>
is a collaborative powerhouse made up of six leading institutions:
<a href=https://www.gatech.edu/ target=_blank>Georgia Tech</a>
,
<a href=https://www.gtri.gatech.edu/ target=_blank>GTRI</a>
,
<a href=https://research.samsung.com/ target=_blank>Samsung Research</a>
,
<a href=https://sra.samsung.com/ target=_blank>Samsung Research America</a>
,
<a href=https://www.kaist.ac.kr/en/ target=_blank>KAIST</a>
, and
<a href=https://www.postech.ac.kr/ target=_blank>POSTECH</a>
.
Each of these organizations is led by Georgia Tech alumni,
and includes past winners of prestigious hacking competitions
such as DEF CON CTF, Pwn2Own and kernelCTF.</p><p>For the past several months, we have been diligently preparing for this competition,
combining our expertise in AI, cybersecurity,
and software engineering.
Last week, we proudly competed in the AIxCC Semifinals,
showcasing our hard work and dedication
to advancing cybersecurity through artificial intelligence.</p><h2 id=the-journey-begins>The Journey Begins</h2><p>When AIxCC was announced <a href=https://www.whitehouse.gov/briefing-room/statements-releases/2023/08/09/biden-harris-administration-launches-artificial-intelligence-cyber-challenge-to-protect-americas-critical-software/ target=_blank>last year</a>
,
we quickly assembled a team of friends,
including <a href=https://www.zellic.io/ target=_blank>Zellic</a>
and <a href=https://gts3.org/ target=_blank>SSLab</a>
.
At that time,
much was uncertain;
details about the game format,
scoring rubric,
proof-of-vulnerability (PoV),
sanitizers, harnesses, supported programming languages,
and proof-of-understanding (PoU) were all unclear.
Our team, however, started preparing for the competition from last October.</p><p>Many of our team members previously participated in the
<a href=https://www.darpa.mil/program/cyber-grand-challenge target=_blank>DARPA Cyber Grand Challenge (CGC)</a>
as part of <a href=https://en.wikipedia.org/wiki/2016_Cyber_Grand_Challenge target=_blank>Crspy</a>
,
where we were responsible for bug finding and exploitation generation.
DARPA CGC was an ambitious endeavor
that sparked numerous innovative research directions afterward.
However, the competition was not without its challenges,
particularly due to the <em>gamification</em> of the event;
the scoring metrics and rules significantly influenced <a href="https://free.eol.cn/edu_net/edudown/spkt/zhangchao.pdf#page=34" target=_blank>the outcomes</a>
.
In the end, the competing Cyber Reasoning Systems (CRS) that focused on operating reactively&ndash;prioritizing the availability score over fixing bugs&ndash;
tended to score higher, as exploitation proved to be far more difficult than patching.</p><p>Aware of <a href=https://aicyberchallenge.com/rules/ target=_blank>the gamification issues</a>
from CGC,
we anticipated that to excel in AIxCC
our CRS should leverage AI, particularly LLMs, aggressively in various depths and levels
of the CRS pipelines.
With this in mind, we strategically chose to focus our efforts on two key directions:</p><ol><li><p><strong>Static Analysis.</strong> To encourage the use of LLMs and set AIxCC apart from CGC,
we anticipated that
AIxCC would strongly advocate for the adoption of <em>static analysis</em> while
steering away from the dominant use of <em>fuzzing</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.
It&rsquo;s important to note
that finding bugs is quite different from finding crash- or bug-triggering
inputs. The latter offers a clear advantage in objectively and autonomously
verifying the discovered bug,
but it has a much narrower scope compared to the former.
In practice, the <em>triggering</em> aspect, also known as the reachability problem, is
a significantly more challenging and crucial issue to address,
where <em>dynamic tools</em> like fuzzing have a clear edge.</p></li><li><p><strong>Fine-tuning LLMs for Source Code.</strong> Specialization is always an advantage
when possible. Given that each CRS will likely need to support more than 10
programming languages during the competition, we decided to fine-tune both
in-house and open-source models for analyzing code.
This approach is conceptually similar to
<a href=https://paperswithcode.com/dataset/commitpack target=_blank>commitPack</a>
,
but focuses on
commits related to bugs like their fixes, bug-introducing commits, descriptions,
and public exploits, if available.
Our expectation was that training with this data would enable
the fine-tuned LLM to reason about security bugs,
their fixes, and likely input corpus,
more effectively than the
foundational model.</p></li></ol><p>We quickly realized that to pursue these directions effectively,
we first needed a dataset: a benchmark.
Our team divided tasks into three areas: 1) static analysis
using LLM prompts/agents, 2) developing a C benchmark from sources like CGC and
OSS-Fuzz, and 3) collecting a training dataset pairing CVEs with patches and PoCs for
open-source projects to fine-tune our in-house code model at Samsung or to
leverage open-source LLMs.</p><p>Remarkably, within 4-5 months, we accomplished all three goals,
and our LLM-based Cyber Reasoning System (CRS), dubbed Skynet,
performed surprisingly well on our benchmark,
and fine-tuning on a smaller dataset shows some promises like in python.</p><p>Time flew by. The cold winter of 2023 ended, and we found ourselves in the new
year of 2024.
I vividly remember that around this time, our dear friends from
Zellic left our team to pursue the Small Business Innovation Research (SBIR) track,
which DARPA supports with $1 million for the competition.
Unfortunately, Georgia Tech and Samsung were not eligible for this award.</p><h2 id=kick-off-with-surprises>Kick-off with Surprises!</h2><img title="image title" loading=lazy decoding=async class="img img-fluid img-center" width=600 height=390 src=/images/blog/atl/timeline_hu27eb7f2762e238941514cfe06aa31894_2087274_600x0_resize_q100_lanczos_3.png alt=alter-text onerror='this.onerror="null",this.src="/images/blog/atl/timeline_hu27eb7f2762e238941514cfe06aa31894_2087274_600x0_resize_q100_lanczos_3.png"'>
<script>window.addEventListener("load",e=>{const t=GLightbox()})</script><p>At the kick-off event on March 29th, AIxCC unveiled the first challenge project:
the Linux kernel, along with an example vulnerability,
<a href=https://nvd.nist.gov/vuln/detail/CVE-2021-43267 target=_blank>CVE-2021-43267</a>
.
This bug is <a href=https://www.sentinelone.com/labs/tipc-remote-linux-kernel-heap-overflow-allows-arbitrary-code-execution/ target=_blank>well documented</a>
,
and its PoC exploit is <a href=https://github.com/zzhacked/CVE-2021-43267 target=_blank>publicly available</a>
,
making it an excellent example to work on.</p><p>What makes this bug even more intriguing is the story behind it.
A security researcher audited the Linux kernel source code using
<a href=https://codeql.github.com/ target=_blank>CodeQL</a>
.
Specifically, the researcher was searching
for instances where 16-bit <code>size</code> parameters are passed to the <code>kmalloc()</code>
function for memory allocation,
using a dataflow-based CodeQL query.
The intuition was that a 16-bit <code>size</code> parameter
could easily lead to an <em>integer overflow</em> when accessing the allocated object.
However, the discovered bug was not caused by an integer overflow,
but an out-of-bound heap overflow due to a missing sanity check on the <code>size</code> and related inputs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>tipc_crypto_key_rcv</span>(<span style=color:#66d9ef>struct</span> tipc_crypto <span style=color:#f92672>*</span>rx, <span style=color:#66d9ef>struct</span> tipc_msg <span style=color:#f92672>*</span>hdr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> tipc_crypto <span style=color:#f92672>*</span>tx <span style=color:#f92672>=</span> <span style=color:#a6e22e>tipc_net</span>(rx<span style=color:#f92672>-&gt;</span>net)<span style=color:#f92672>-&gt;</span>crypto_tx;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> tipc_aead_key <span style=color:#f92672>*</span>skey <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>	u16 key_gen <span style=color:#f92672>=</span> <span style=color:#a6e22e>msg_key_gen</span>(hdr);
</span></span><span style=display:flex><span>	u16 size <span style=color:#f92672>=</span> <span style=color:#a6e22e>msg_data_sz</span>(hdr);
</span></span><span style=display:flex><span>	u8 <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> <span style=color:#a6e22e>msg_data</span>(hdr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* Allocate memory for the key */</span>
</span></span><span style=display:flex><span>	skey <span style=color:#f92672>=</span> <span style=color:#a6e22e>kmalloc</span>(size, GFP_ATOMIC);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(<span style=color:#f92672>!</span>skey)) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>pr_err</span>(<span style=color:#e6db74>&#34;%s: unable to allocate memory for skey</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, rx<span style=color:#f92672>-&gt;</span>name);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>goto</span> exit;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* Copy key from msg data */</span>
</span></span><span style=display:flex><span>	skey<span style=color:#f92672>-&gt;</span>keylen <span style=color:#f92672>=</span> <span style=color:#a6e22e>ntohl</span>(<span style=color:#f92672>*</span>((__be32 <span style=color:#f92672>*</span>)(data <span style=color:#f92672>+</span> TIPC_AEAD_ALG_NAME)));
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>memcpy</span>(skey<span style=color:#f92672>-&gt;</span>alg_name, data, TIPC_AEAD_ALG_NAME);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>memcpy</span>(skey<span style=color:#f92672>-&gt;</span>key, data <span style=color:#f92672>+</span> TIPC_AEAD_ALG_NAME <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(__be32),
</span></span><span style=display:flex><span>	       skey<span style=color:#f92672>-&gt;</span>keylen);
</span></span></code></pre></div><p>The <code>skey</code> was allocated with a <code>size</code> based on the user-provided <code>hdr</code>,
but <code>skey->key</code> was copied up to <code>skey->keylen</code>,
which was also user-controlled and could therefore be inconsistent with <code>size</code>.
Unfortunately, the kernel did not
perform a sanity check on these two parameters,
causing an out-of-boundary access.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>commit fa40d9734a57bcbfa79a280189799f76c88f7bb0
</span></span><span style=display:flex><span>Author: Max VA &lt;maxv@sentinelone.com&gt;
</span></span><span style=display:flex><span>Date:   Mon Oct 25 17:31:53 2021 +0200
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tipc: fix size validations for the MSG_CRYPTO type
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    The function tipc_crypto_key_rcv is used to parse MSG_CRYPTO messages
</span></span><span style=display:flex><span>    to receive keys from other nodes in the cluster in order to decrypt any
</span></span><span style=display:flex><span>    further messages from them.
</span></span><span style=display:flex><span>    This patch verifies that any supplied sizes in the message body are
</span></span><span style=display:flex><span>    valid for the received message.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>diff --git a/net/tipc/crypto.c b/net/tipc/crypto.c
</span></span><span style=display:flex><span>index c9391d38de85..dc60c32bb70d 100644
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/net/tipc/crypto.c
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/net/tipc/crypto.c
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -2285,43 +2285,53 @@ static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	u16 key_gen = msg_key_gen(hdr);
</span></span><span style=display:flex><span> 	u16 size = msg_data_sz(hdr);
</span></span><span style=display:flex><span> 	u8 *data = msg_data(hdr);
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	unsigned int keylen;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	/* Verify whether the size can exist in the packet */
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(size &lt; sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_debug(&#34;%s: message data size is too small\n&#34;, rx-&gt;name);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		goto exit;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	/* Verify the supplied size values */
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		     keylen &gt; TIPC_AEAD_KEY_SIZE_MAX)) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		pr_debug(&#34;%s: invalid MSG_CRYPTO key size\n&#34;, rx-&gt;name);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		goto exit;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span></code></pre></div><p>Two checks were added to fix this bug:
verifying that <code>size</code> is greater than the
minimum key size, and ensuring that <code>keylen</code> is consistent with <code>size</code>,
thereby preventing access beyond the allocated object.</p><h2 id=misunderstanding-1-pov>Misunderstanding 1: PoV</h2><p>Given a massive Linux repository (yes, 20 million lines of code),
where should we start?
The LLM approach is all about asking the right questions,
also known as prompt engineering.
We utilized various techniques like Chain-of-Thought (CoT)
and Tree-of-Thoughts (ToT),
and were exploring Retrieval Augmented Generation (RAG)
to quickly identify known 1-day bugs.</p><p>At that time, context size was limited;
the most advanced model, <code>gpt-3.5 turbo</code>
(yes, pre-<code>gpt-4</code> era) from OpenAI, supported 16k tokens,
making it crucial to ask the right question!
We initially tried identifying potentially vulnerable
code snippets using a range of static analysis tools,
including CodeQL, Semgrep and various tools from academic publications,
and then filtered the results with LLMs.
We even considered diffing the upstream Linux kernel
against the provided repository,
so that our CRS can look at the modified part of the code first.</p><p>We were confident our decision; to promote the use of AI tools,
the AIxCC organizers
would design the competition in a way that allows a single CRS codebase to
explore any code repository using 10+ programming languages and their
combinations.</p><p>Ah, around that time,
Google had just announced <code>gemini-pro</code>
with an impressive 128k context and the potential to support 1 million tokens!
Meanwhile, <code>gpt-4</code>
introduced a game-changing feature called function calling,
which allows the LLM to select which callback to use and integrate the results back into the prompt
at runtime. We felt that everything was evolving favorably for our CRS to adopt
these cutting-edge techniques.</p><p>However, PoV turned out to mean <em>bug-triggering input</em>
or a crashing input.
To demonstrate the existence of a bug,
each CRS needed to formulate an input
that the referee could quickly verify.
While this approach is
straightforward and objective for the competition,
it significantly discourages the adoption of LLMs in finding bugs.
Our team quickly realized
that we needed to pivot to the dynamic approaches like fuzzing
for the competition.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tipc_trigger</span>(<span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>smashbuf, <span style=color:#66d9ef>uint32_t</span> smashlen, <span style=color:#66d9ef>int</span> seqno) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> pkt[<span style=color:#ae81ff>0x1000</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> w0, w1, w2, w3, w4, w5;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    w0 <span style=color:#f92672>=</span> <span style=color:#a6e22e>hdr_version</span>(TIPC_VERSION);
</span></span><span style=display:flex><span>    w0 <span style=color:#f92672>|=</span> <span style=color:#a6e22e>hdr_size</span>(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    w0 <span style=color:#f92672>|=</span> <span style=color:#a6e22e>hdr_user</span>(MSG_CRYPTO);
</span></span><span style=display:flex><span>    w0 <span style=color:#f92672>|=</span> <span style=color:#a6e22e>hdr_msg_size</span>(<span style=color:#ae81ff>24</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>36</span> <span style=color:#f92672>+</span> KEY_SIZE);
</span></span><span style=display:flex><span>    w1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    w2 <span style=color:#f92672>=</span> seqno;
</span></span><span style=display:flex><span>    w3 <span style=color:#f92672>=</span> NODE_ID;
</span></span><span style=display:flex><span>    w4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    w5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(pkt, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(pkt));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gen_tipc_hdr</span>(pkt, w0, w1, w2, w3, w4, w5);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(pkt<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>, <span style=color:#e6db74>&#34;HAXX&#34;</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>*</span>)(pkt<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span><span style=color:#f92672>+</span><span style=color:#ae81ff>32</span>) <span style=color:#f92672>=</span> <span style=color:#a6e22e>be32</span>(KEY_SIZE <span style=color:#f92672>+</span> SMASH_SIZE <span style=color:#f92672>+</span> smashlen); <span style=color:#75715e>// &lt;- (1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>memset</span>(pkt<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span><span style=color:#f92672>+</span><span style=color:#ae81ff>36</span>, <span style=color:#e6db74>&#39;C&#39;</span>, KEY_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(pkt<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span><span style=color:#f92672>+</span><span style=color:#ae81ff>36</span><span style=color:#f92672>+</span>KEY_SIZE, <span style=color:#e6db74>&#39;D&#39;</span>, SMASH_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(pkt<span style=color:#f92672>+</span><span style=color:#ae81ff>24</span><span style=color:#f92672>+</span><span style=color:#ae81ff>36</span><span style=color:#f92672>+</span>KEY_SIZE <span style=color:#f92672>+</span> SMASH_SIZE, smashbuf, smashlen);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tipc_send</span>(pkt, <span style=color:#66d9ef>sizeof</span>(pkt));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Formulating a bug-triggering input, including ensuring its reachability,
is a far more challenging task than simply spotting buggy code in the repository.
The strength of fuzzing, perhaps the opposite of a sophisticated LLM,
is that once a bug is found,
you almost always have a bug-triggering input.</p><p>In CVE-2021-43267, using CodeQL and auditing,
one could identify this bug, but triggering it is an entirely different challenge,
not to mention <a href=https://github.com/zzhacked/CVE-2021-43267/blob/main/poc.py target=_blank>exploiting it</a>
.
For example,
TIPC must be properly set up first, and the <code>keylen</code> needs to be precisely
crafted in (1) to trigger the bug.</p><h2 id=misunderstanding-2-harnesses>Misunderstanding 2. Harnesses</h2><p>Sorry, what&rsquo;s the input needed to trigger CVE-2021-43267? even with a fuzzer?<br>To fuzz the Linux <em>kernel</em>,
we needed a <em>user</em> program
that calls a sequence of system calls
with various arguments.
Considering the Linux kernel has over <a href=https://filippo.io/linux-syscall-table/ target=_blank>400 system calls</a>
to explore, this was far
from ideal for a competition setting.</p><p>We initially assumed that harnesses and test cases would be provided to indicate
which parts of the Linux kernel should be checked for bugs.
To tackle this,
we implemented and adopted various versions of Linux kernel fuzzers,
including a custom kernel syscall fuzzer with <code>kcov</code> and <code>kcmp</code>,
and also utilized the most popular Linux fuzzer, <a href=https://github.com/google/syzkaller target=_blank>Syzkaller</a>
.
However, our focus remained on determining which sequences of system calls
to test, using syscall traces and static analysis of the provided program,
and then correctly formulating an end-to-end userspace program to trigger the bug.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/***
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Blob begins with a 4 byte command count
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [4-bytes command count]
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Currently there are two commands:
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  0 - send a packet blob
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      [4-bytes size][4-bytes send flags][size-bytes packet data]
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  1 - send a netlink packet
</span></span></span><span style=display:flex><span><span style=color:#75715e> *      [4-bytes Message Type][4-bytes Message Flags][4-bytes Netlink Protocol][4-bytes size][size bytes data]
</span></span></span><span style=display:flex><span><span style=color:#75715e> * blob_size MUST be a trusted value
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>harness</span>( <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>blob, <span style=color:#66d9ef>uint32_t</span> blob_size)
</span></span><span style=display:flex><span>{ ... }
</span></span></code></pre></div><p><a href=https://github.com/aixcc-public/challenge-001-exemplar/ target=_blank>The Linux Kernel CP</a>
was announced in April and came with a harness,
<a href=https://github.com/aixcc-public/challenge-001-exemplar-source/blob/main/test_harnesses/linux_test_harness.c target=_blank>linux_test_harness.c</a>
.
This announcement was full of surprises;
the program&rsquo;s structure was provided by the harness,
which is alas what we primarily focused on,
and the <a href=https://github.com/aixcc-public/challenge-001-exemplar/blob/main/exemplar_only/blobs/sample_solve.bin target=_blank><code>blob</code></a>
needed to be fed to the harness in a way that triggers the bug.
The types of system calls we could interact with
were limited by the harness,
and our task was to find the right data input
that would <em>lead the harness</em>
to invoke the necessary sequence of system calls with the correct parameters.
In other words, we needed to understand the harness first
before dealing with the Linux kernel bugs.</p><p>Later, the Jenkins harness was announced, and more surprisingly,
it was a fuzz driver (often called a <em>fuzzing harness</em>),
a standalone program designed to
invoke APIs for fuzz testing.
In May, a new CP, called <code>mock-cp</code> (a userspace program),
was introduced along with a new harness format, which was simply a
shell script executing a CP binary with the provided input.
Such diverse formats got us thinking that
our CRS should adopt LLM to figure out the structure of the programs
and CPs first; like how to compile, how to correctly run, etc.</p><p>By June, the harness format was officially established -
surprisingly, yet not entirely unexpected:
<a href=https://llvm.org/docs/LibFuzzer.html target=_blank>libfuzzer</a>
for
userspace programs (<code>mock-cp</code> and Nginx),
<a href=https://github.com/CodeIntelligenceTesting/jazzer target=_blank>jazzer</a>
for Java programs
(Jenkins), while retaining the <code>blob</code>-based harness for the Linux kernel.
We continually updated our CRS to adapt to these changes,
but many of these decisions rendered our LLM-based components unnecessary.
This decision, however,
greatly helped all the participating teams
by reducing the engineering time needed for game operation.
Unfortunately, we were too proactive in reacting to these changes and ended up
wasting some engineering time as a result ðŸ˜Š.</p><p>A harness&rsquo;s role is crucial in the AIxCC competition; it sets the context for
the CRS to trigger the bug and serves as a key factor in adjusting the
difficulty of bug discovery. Therefore, it&rsquo;s important to strike a balance:
it should provide enough detail to relieve the CRS from unnecessary burdens,
allowing it to focus on bug finding, but without revealing too much information
about the bugs.</p><h2 id=misunderstanding-3-proof-of-understanding>Misunderstanding 3. Proof-of-understanding</h2><p>Unlike CGC, which treated the PoV (a proof-of-concept exploit)
as sufficient proof of bug discovery,
AIxCC required additional informationâ€”specifically, the bug type as classified by
<a href=https://cwe.mitre.org/top25/archive/2023/2023_kev_list.html target=_blank>CWE</a>
,
to be provided along with the PoV.
This was an interesting decision, as AIxCC required
CRS to find bugs in the source code,
whereas CGC focused on discovering bugs in binaries.</p><p>Our team spent a lot of time brainstorming
how to accurately identify CWE categories,
primarily by using LLM prompts that leverage crashing inputs,
sanitizer reports, related code snippets, outputs from static analyzers, and more.
However, the notion of CWEs can be ambiguous when used as a scoring
mechanism for the competition.
For instance, should CVE-2021-43267 be classified
as (1) CWE-122 (Heap-based Buffer Overflow), (2) CWE-787 (Out-of-bounds Write),
or (3) CWE-20 (Improper Input Validation)?
The first two describe the symptoms
caused by the bug, while the third identifies the root cause, as the patch for
this bug involved adding input validations.</p><p>In the end, AIxCC shifted the focus from PoV to identifying the bug-introducing
commit (BIC) - the specific hash or commit ID in the git repository.
Combined with
the fuzzing harness and PoV, the CRS&rsquo;s task was to run the fuzzing harness and
perform a <a href=https://git-scm.com/docs/git-bisect target=_blank><code>git-bisect</code></a>
to pinpoint
the BIC in the repository.
We did a simple bisecting in the semifinal but lots of improvement
required to be functional for the final event.</p><h2 id=misunderstanding-4-semantic-patching>Misunderstanding 4. Semantic patching</h2><p>Patching is one of the most intriguing aspects of AIxCC. In CGC, the PoV was
typically a simple exploit (like arbitrary read/write/execute),
so mitigation strategies (e.g., adding a stack canary) could effectively thwart the PoV.
In fact, patches could be applied <em>without even knowing</em> the specific bug;
for example,
adding a stack canary to all functions in a binary
can prevent buffer overflow exploits
that might exist in some places.</p><p>The challenge in CGC was that the focus was on the binary, and the organizers
introduced rules such as a minimum number of bytes changed and performance
overheads added to the scoring rubric (e.g., instrumenting all memory accesses
to prevent out-of-bound errors). These rules were designed to encourage
competitors to generate correct patches. Ultimately, this forced CRS to weigh
the pros and cons of universal patching, as both exploiting and patching were
extremely difficult during the CGC era,
resulting in a trade-off between losing
points from exploitation versus losing points from patching and availability.</p><p>In AIxCC, the CRS must generate a semantically correct patch that not only fixes
the identified PoV but also maintains the functional correctness of the CP. This
is a tricky task, as <em>correctness</em> cannot be formally defined for CRS - some
functional changes may be acceptable, while others may not, depending on the
code owner&rsquo;s criteria.
One approach to addressing this ambiguity is to provide
test code to see if the patch passes the provided, so-called public tests.
However, CRS must still account for private tests set by the organizers.</p><p>In the semifinals, our CRS submitted a patch that successfully prevented the
crash and passed the public tests given to us during the competition,
but was ultimately rejected in the private
functionality tests.
We&rsquo;re eager to learn more about the bug and the patch!</p><h2 id=misunderstanding-5-sanitizers>Misunderstanding 5: Sanitizers</h2><p>The concept of sanitizers was unclear to our team until we encountered
their concrete implementation
for memory-safe languages like Java, and more
specifically, for Jenkins, a web application written in Java!
The role of a sanitizer, essentially a bug oracle, is to determine whether a bug has been
correctly triggered.</p><p>In memory-unsafe languages like C, standard tools like ASAN and UBSAN can serve
as sanitizers to catch memory-safety issues with low or no false positives
(e.g., out-of-bound accesses should never occur).
However, in memory-safe languages,
things get trickier.
For example, is executing a command a legitimate
feature in CI tools like Jenkins,
or should it be treated as a command injection (CWE-78)?</p><p>In other words, sanitizers are more CP-specific
rather than programming language-specific;
each CP needs to provide custom sanitizers
(e.g., <a href=https://www.code-intelligence.com/blog/java-fuzzing-with-jazzer target=_blank>path traversal sanitizers</a>
).</p><p>Our team initially spent time working on finding web-related bugs like XSS or
CSRF in Jenkins - areas where we believed LLMs could excel in seed generation.
However, once AIxCC announced
that the sanitizers for Java would be
<a href=https://github.com/CodeIntelligenceTesting/jazzer target=_blank>jazzer</a>
sanitizers,
we decided to shift our focus more towards standard jazzer-based fuzzing.</p><h2 id=semifinal>Semifinal</h2><p>Our team dedicated most of our engineering effort to building a CRS for the
Linux Kernel, and we&rsquo;re proud that our CRS was able to find and correctly
generate a patch for CVE-2021-43267 in the end.
However, during the semifinal,
it appeared that only <em>one</em> harness was provided, similar to the exemplar, and
none of the CRSes functioned properly for the Linux Kernel.
We loved to know more about how our Linux CRS functioned
during the competition.</p><img title="image title" loading=lazy decoding=async class="img img-fluid img-center" width=600 height=404 src=/images/blog/atl/dashboard_hucdfac242ccfb260b6c8aa0c492f17fbb_248513_600x0_resize_q100_lanczos_3.png alt=alter-text onerror='this.onerror="null",this.src="/images/blog/atl/dashboard_hucdfac242ccfb260b6c8aa0c492f17fbb_248513_600x0_resize_q100_lanczos_3.png"'><p>In summary, our CRS earned a total of six achievement badges: five for
discovering bugs (i.e., first bloods) and one for a patch.</p><img title="image title" loading=lazy decoding=async class="img img-fluid img-center" width=600 height=333 src=/images/blog/atl/achievements_hu5072cc1c531c3d4ed879245bc9c46aa6_852847_600x0_resize_q100_lanczos_3.png alt=alter-text onerror='this.onerror="null",this.src="/images/blog/atl/achievements_hu5072cc1c531c3d4ed879245bc9c46aa6_852847_600x0_resize_q100_lanczos_3.png"'><p>Our CRS found several unique bugs, which we will describe in a later blog post!</p><p>Aside from the known CPsâ€”Linux (C), Jenkins (Java), and Nginx (C) - there were new
CPs introduced, namely Tika (Java) and sqlite3 (C).
Our CRS performed relatively
well on sqlite3, but unfortunately,
our Java CRS struggled with Tika.
We would love to learn more about what happened during the competition.
Tika, a popular file format parser,
has many unique features, such as recursively parsing
embedded objects,
which may have contributed to the challenges we faced.</p><h2 id=looking-ahead-to-the-aixcc-final->Looking Ahead to the AIxCC Final ðŸŽ‰</h2><figure class=img-center role=group aria-describedby="caption-AIxCC Finalists"><img title="image title" loading=lazy decoding=async class="img img-fluid" width=600 height=331 src=/images/blog/atl/finalists_hua191f10a8c6185b27f399163513ba79a_538686_600x0_resize_q100_lanczos_3.png alt=alter-text onerror='this.onerror="null",this.src="/images/blog/atl/finalists_hua191f10a8c6185b27f399163513ba79a_538686_600x0_resize_q100_lanczos_3.png"'><figcaption id="caption-AIxCC Finalists" class=caption-AIxCC-Finalists>AIxCC Finalists</figcaption></figure><p>We are thrilled that our team has advanced to the AIxCC finals! We have several ideas that could make the competition even more exciting:</p><ul><li><p><strong>Different execution times based on code complexity.</strong><br>The Linux kernel, with its 6,000 files and 20 million lines of code, requires
substantial time for bookkeeping like building, bootstrapping, and bisecting.
Compared to smaller programs (e.g., 200k in Tika), it would be beneficial to
allocate more time for CRSes to navigate such complex codebases.</p></li><li><p><strong>More programming languages and their combinations.</strong><br>Top candidates include Python, Rust, and JavaScript/HTML, along with
combinations like JNI (C) in Java or Rust device drivers in the Linux kernel.
These would offer a more comprehensive evaluation of CRS capabilities in
diverse and challenging settings where CRS is most needed.</p></li><li><p><strong>Standardized execution environments.</strong><br>Standardizing the compiler (e.g., <code>clang-18</code>), runtime (e.g., JVM version),
and base Docker image ahead of time would help teams explore more advanced
techniques, such as LLM-based instrumentation, in a controlled environment.</p></li><li><p><strong>Improved visualization during the competition.</strong><br>While the AIxCC village was impressively set up, competing teams and
participants had limited visibility into the competition&rsquo;s progress and how
each CRS was functioning. To capture more attention from <a href=https://www.reddit.com/r/Defcon/comments/1eta3tj/was_the_aixcc_village_disappointing_to_anyone_else/ target=_blank>the DEF CON audience</a>
,
it would be beneficial to expose more technical information during the
competition - such as showing current prompts of each CRS in turn, their CPU
usage, or even stdout from CRSes (for fun), along with explanations of the
progress.</p></li></ul><p>With our baseline system up and running, itâ€™s time for our team to explore the
possibility of incorporating LLMs or ML techniques into our CRS workflow. If
youâ€™re passionate about AIxCC and as committed to the competition as we are,
feel free to <a href=mailto:aixcc-atl@googlegroups.com>contact us</a>
!</p><p>We are fortunate to have support from generous sponsors like GT/GTRI, Samsung,
and KAIST/NYU. If your company is interested in sponsoring our team, we would be
happy to discuss further!</p><p>Last but not least, we want to extend our heartfelt thanks to the AIxCC
organizers for launching the competition we&rsquo;ve been craving. Hackers thrive on
competition-driven innovation, and this has been an exciting opportunity for all
of us.</p><div style="width:640px;margin:0 auto"><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/FkJimGWJYgw style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I think itâ€™s one of the worst names ever chosen by a security researcher; non-security folks often think it&rsquo;s a really <em>dumb</em> technique. But if you dig into the details, it&rsquo;s actually an impressive AI tool. It operates entirely autonomously, adapting to unknown code, self-learning from past executions, using feedback loops similar to backpropagation, and employing cost functions like coverage maps, and more! Most importantly, like deep learning, it works incredibly well in practice!&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class="row items-start justify-between"><div class="lg:col-5 mb-10 flex items-center lg:mb-0"><h5 class=mr-3>Tags :</h5><ul><li class=inline-block><a class="bg-theme-light hover:bg-primary dark:bg-darkmode-theme-light dark:hover:bg-darkmode-primary dark:hover:text-dark m-1 block rounded px-3 py-1 hover:text-white" href=/tags/team/>Team</a></li></ul></div><div class="lg:col-4 flex items-center"><div class=share-icons><h5 class=share-title>Share :</h5><a class="share-link share-facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fteam-atlanta.github.io%2fblog%2fpost-atl%2f" target=_blank rel=noopener aria-label="share facebook"><span class=share-icon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.77 7.46H14.5v-1.9c0-.9.6-1.1 1-1.1h3V.5h-4.33C10.24.5 9.5 3.44 9.5 5.32v2.15h-3v4h3v12h5v-12h3.85l.42-4z"/></svg></span></a><a class="share-link share-twitter" href="https://twitter.com/intent/tweet/?text=Share&amp;url=https%3a%2f%2fteam-atlanta.github.io%2fblog%2fpost-atl%2f" target=_blank rel=noopener aria-label="share twitter"><span aria-hidden=true class=share-icon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M23.44 4.83c-.8.37-1.5.38-2.22.02.93-.56.98-.96 1.32-2.02-.88.52-1.86.9-2.9 1.1-.82-.88-2-1.43-3.3-1.43-2.5.0-4.55 2.04-4.55 4.54.0.36.03.7.1 1.04-3.77-.2-7.12-2-9.36-4.75-.4.67-.6 1.45-.6 2.3.0 1.56.8 2.95 2 3.77-.74-.03-1.44-.23-2.05-.57v.06c0 2.2 1.56 4.03 3.64 4.44-.67.2-1.37.2-2.06.08.58 1.8 2.26 3.12 4.25 3.16C5.78 18.1 3.37 18.74 1 18.46c2 1.3 4.4 2.04 6.97 2.04 8.35.0 12.92-6.92 12.92-12.93.0-.2.0-.4-.02-.6.9-.63 1.96-1.22 2.56-2.14z"/></svg></span></a><a class="share-link share-email" href="mailto:?subject=Share&amp;body=https%3a%2f%2fteam-atlanta.github.io%2fblog%2fpost-atl%2f" target=_self rel=noopener aria-label="share email"><span aria-hidden=true class=share-icon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 4H2C.9 4 0 4.9.0 6v12c0 1.1.9 2 2 2h20c1.1.0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7.25 14.43l-3.5 2c-.08.05-.17.07-.25.07-.17.0-.34-.1-.43-.25-.14-.24-.06-.55.18-.68l3.5-2c.24-.14.55-.06.68.18.14.24.06.55-.18.68zm4.75.07c-.1.0-.2-.03-.27-.08l-8.5-5.5c-.23-.15-.3-.46-.15-.7.15-.22.46-.3.7-.14L12 13.4l8.23-5.32c.23-.15.54-.08.7.15.14.23.07.54-.16.7l-8.5 5.5c-.08.04-.17.07-.27.07zm8.93 1.75c-.1.16-.26.25-.43.25-.08.0-.17-.02-.25-.07l-3.5-2c-.24-.13-.32-.44-.18-.68s.44-.32.68-.18l3.5 2c.24.13.32.44.18.68z"/></svg></span></a><a class="share-link share-reddit" href="https://reddit.com/submit/?url=https%3a%2f%2fteam-atlanta.github.io%2fblog%2fpost-atl%2f&amp;resubmit=true&amp;title=Share" target=_blank rel=noopener aria-label="share reddit"><span aria-hidden=true class=share-icon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 11.5c0-1.65-1.35-3-3-3-.96.0-1.86.48-2.42 1.24-1.64-1-3.75-1.64-6.07-1.72.08-1.1.4-3.05 1.52-3.7.72-.4 1.73-.24 3 .5C17.2 6.3 18.46 7.5 20 7.5c1.65.0 3-1.35 3-3s-1.35-3-3-3c-1.38.0-2.54.94-2.88 2.22-1.43-.72-2.64-.8-3.6-.25-1.64.94-1.95 3.47-2 4.55-2.33.08-4.45.7-6.1 1.72C4.86 8.98 3.96 8.5 3 8.5c-1.65.0-3 1.35-3 3 0 1.32.84 2.44 2.05 2.84-.03.22-.05.44-.05.66.0 3.86 4.5 7 10 7s10-3.14 10-7c0-.22-.02-.44-.05-.66 1.2-.4 2.05-1.54 2.05-2.84zM2.3 13.37C1.5 13.07 1 12.35 1 11.5c0-1.1.9-2 2-2 .64.0 1.22.32 1.6.82-1.1.85-1.92 1.9-2.3 3.05zm3.7.13c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9.8 4.8c-1.08.63-2.42.96-3.8.96-1.4.0-2.74-.34-3.8-.95-.24-.13-.32-.44-.2-.68.15-.24.46-.32.7-.18 1.83 1.06 4.76 1.06 6.6.0.23-.13.53-.05.67.2.14.23.06.54-.18.67zm.2-2.8c-1.1.0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm5.7-2.13c-.38-1.16-1.2-2.2-2.3-3.05.38-.5.97-.82 1.6-.82 1.1.0 2 .9 2 2 0 .84-.53 1.57-1.3 1.87z"/></svg></span></a></div></div></div></article></div></div></section></main><footer class="bg-theme-light dark:bg-darkmode-theme-light"><div class=container><div class="row items-center py-10"><div class="lg:col-3 mb-8 text-center lg:mb-0 lg:text-left"><a class="navbar-brand inline-block" href=/>Team Atlanta</a></div><div class="lg:col-6 mb-8 text-center lg:mb-0"><ul><li class="m-3 inline-block"><a href=/about/>About</a></li></ul></div><div class="lg:col-3 mb-8 text-center lg:mb-0 lg:mt-0 lg:text-right"><ul class=social-icons><li><a target=_blank aria-label=www rel="nofollow noopener" href=https://team-atlanta.github.io/><i class="fa-solid fa-house"></i></a></li><li><a target=_blank aria-label=twitter rel="nofollow noopener" href=https://x.com/TeamAtlanta24><i class="fab fa-twitter"></i></a></li><li><a target=_blank aria-label=github rel="nofollow noopener" href=https://github.com/Team-Atlanta/><i class="fab fa-github"></i></a></li></ul></div></div></div><div class="border-border dark:border-darkmode-border border-t py-7"><div class="text-light dark:text-darkmode-light container text-center"><p>Designed & Developed by <a href=https://zeon.studio target=_blank>Zeon Studio</a></p></div></div></footer><script crossorigin=anonymous integrity="sha256-JfCl05bpANVgFfythUbUTL7SszmLQ7wWqsqrkYSOBkU=" src=/js/script.min.25f0a5d396e900d56015fcad8546d44cbed2b3398b43bc16aacaab91848e0645.js></script><script defer async crossorigin=anonymous integrity="sha256-B6xkgfh/Kvqv5KhwfzCl2bDxX83d75UmDJHTJqlOs3M=" src=/js/script-lazy.min.07ac6481f87f2afaafe4a8707f30a5d9b0f15fcdddef95260c91d326a94eb373.js></script><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></body></html>